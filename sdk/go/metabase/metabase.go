// Code generated by Pulumi SDK Generator DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package metabase

import (
	"context"
	"reflect"

	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

type Metabase struct {
	pulumi.ResourceState

	// The DNS name for the Metabase instance.
	DnsName pulumi.StringOutput `pulumi:"dnsName"`
	// The security group id for the Metabase instance.
	SecurityGroupId pulumi.StringOutput `pulumi:"securityGroupId"`
}

// NewMetabase registers a new resource with the given unique name, arguments, and options.
func NewMetabase(ctx *pulumi.Context,
	name string, args *MetabaseArgs, opts ...pulumi.ResourceOption) (*Metabase, error) {
	if args == nil {
		args = &MetabaseArgs{}
	}

	var resource Metabase
	err := ctx.RegisterRemoteComponentResource("metabase:index:Metabase", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

type metabaseArgs struct {
	Domain *CustomDomain `pulumi:"domain"`
	// The version of Metabase to run - used as a tag on the `metabase/metabase` Dockerhub image.
	MetabaseVersion *string     `pulumi:"metabaseVersion"`
	Networking      *Networking `pulumi:"networking"`
	// The VPC to use for the Metabase cluster.
	VpcId *string `pulumi:"vpcId"`
}

// The set of arguments for constructing a Metabase resource.
type MetabaseArgs struct {
	Domain CustomDomainPtrInput
	// The version of Metabase to run - used as a tag on the `metabase/metabase` Dockerhub image.
	MetabaseVersion pulumi.StringPtrInput
	Networking      NetworkingPtrInput
	// The VPC to use for the Metabase cluster.
	VpcId pulumi.StringPtrInput
}

func (MetabaseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*metabaseArgs)(nil)).Elem()
}

type MetabaseInput interface {
	pulumi.Input

	ToMetabaseOutput() MetabaseOutput
	ToMetabaseOutputWithContext(ctx context.Context) MetabaseOutput
}

func (*Metabase) ElementType() reflect.Type {
	return reflect.TypeOf((**Metabase)(nil)).Elem()
}

func (i *Metabase) ToMetabaseOutput() MetabaseOutput {
	return i.ToMetabaseOutputWithContext(context.Background())
}

func (i *Metabase) ToMetabaseOutputWithContext(ctx context.Context) MetabaseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MetabaseOutput)
}

// MetabaseArrayInput is an input type that accepts MetabaseArray and MetabaseArrayOutput values.
// You can construct a concrete instance of `MetabaseArrayInput` via:
//
//          MetabaseArray{ MetabaseArgs{...} }
type MetabaseArrayInput interface {
	pulumi.Input

	ToMetabaseArrayOutput() MetabaseArrayOutput
	ToMetabaseArrayOutputWithContext(context.Context) MetabaseArrayOutput
}

type MetabaseArray []MetabaseInput

func (MetabaseArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Metabase)(nil)).Elem()
}

func (i MetabaseArray) ToMetabaseArrayOutput() MetabaseArrayOutput {
	return i.ToMetabaseArrayOutputWithContext(context.Background())
}

func (i MetabaseArray) ToMetabaseArrayOutputWithContext(ctx context.Context) MetabaseArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MetabaseArrayOutput)
}

// MetabaseMapInput is an input type that accepts MetabaseMap and MetabaseMapOutput values.
// You can construct a concrete instance of `MetabaseMapInput` via:
//
//          MetabaseMap{ "key": MetabaseArgs{...} }
type MetabaseMapInput interface {
	pulumi.Input

	ToMetabaseMapOutput() MetabaseMapOutput
	ToMetabaseMapOutputWithContext(context.Context) MetabaseMapOutput
}

type MetabaseMap map[string]MetabaseInput

func (MetabaseMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Metabase)(nil)).Elem()
}

func (i MetabaseMap) ToMetabaseMapOutput() MetabaseMapOutput {
	return i.ToMetabaseMapOutputWithContext(context.Background())
}

func (i MetabaseMap) ToMetabaseMapOutputWithContext(ctx context.Context) MetabaseMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MetabaseMapOutput)
}

type MetabaseOutput struct{ *pulumi.OutputState }

func (MetabaseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Metabase)(nil)).Elem()
}

func (o MetabaseOutput) ToMetabaseOutput() MetabaseOutput {
	return o
}

func (o MetabaseOutput) ToMetabaseOutputWithContext(ctx context.Context) MetabaseOutput {
	return o
}

type MetabaseArrayOutput struct{ *pulumi.OutputState }

func (MetabaseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Metabase)(nil)).Elem()
}

func (o MetabaseArrayOutput) ToMetabaseArrayOutput() MetabaseArrayOutput {
	return o
}

func (o MetabaseArrayOutput) ToMetabaseArrayOutputWithContext(ctx context.Context) MetabaseArrayOutput {
	return o
}

func (o MetabaseArrayOutput) Index(i pulumi.IntInput) MetabaseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *Metabase {
		return vs[0].([]*Metabase)[vs[1].(int)]
	}).(MetabaseOutput)
}

type MetabaseMapOutput struct{ *pulumi.OutputState }

func (MetabaseMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Metabase)(nil)).Elem()
}

func (o MetabaseMapOutput) ToMetabaseMapOutput() MetabaseMapOutput {
	return o
}

func (o MetabaseMapOutput) ToMetabaseMapOutputWithContext(ctx context.Context) MetabaseMapOutput {
	return o
}

func (o MetabaseMapOutput) MapIndex(k pulumi.StringInput) MetabaseOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *Metabase {
		return vs[0].(map[string]*Metabase)[vs[1].(string)]
	}).(MetabaseOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*MetabaseInput)(nil)).Elem(), &Metabase{})
	pulumi.RegisterInputType(reflect.TypeOf((*MetabaseArrayInput)(nil)).Elem(), MetabaseArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*MetabaseMapInput)(nil)).Elem(), MetabaseMap{})
	pulumi.RegisterOutputType(MetabaseOutput{})
	pulumi.RegisterOutputType(MetabaseArrayOutput{})
	pulumi.RegisterOutputType(MetabaseMapOutput{})
}
